
Basic meaning and syntax
---------

Both keywords can be used in the declaration of objects as well as functions. The basic difference when applied to objects is this:

- `const` declares an object as constant. This implies a guarantee that, once initialized, the value of that object won't change, 
and the compiler can make use of this fact for optimizations. It also helps prevent the programmer from writing code that modifies objects
that were not meant to be modified after initialization.

- `constexpr` declares an object as fit for use in what the Standard calls constant expressions. But note that `constexpr` is not the only way to do this.

When applied to functions the basic difference is this:

- `const` can only be used for non-static member functions, not functions in general. It gives a guarantee that the member function
does not modify any of the non-static data members.

- `constexpr` can be used with both member and non-member functions, as well constructors. It declares the function fit for use 
in constant expressions. The compiler will only accept it if the function meets certain criteria (7.1.5/3,4), most importantly (†):

  - The function body must be non-virtual and extremely simple: Apart from typedefs and static asserts, only a single return statement is allowed. In the case of a constructor, only an initialization list, typedefs and static assert are allowed. (= default and = delete are allowed, too, though.)
  - The arguments and the return type must be literal types (i.e., generally speaking, very simple types, typically scalars or aggregates)

So when do I actually have to use constexpr?
-------------

- An object like N above can be used as constant expression without being declared constexpr. This is true for all objects that are:

  - const
  - of integral or enumeration type and
  - initialized at declaration time with an expression that is itself a constant expression 

- For a **function** to be fit for use in constant expressions, it **must** be explicitly declared constexpr; it is not sufficient for it merely to satisfy the criteria for constant-expression functions. Example:

```c++
template <int N>
class list
{ };

constexpr int sqr1(int arg)
{ return arg*arg; }

int sqr2(int arg)
{ return arg*arg; }

int main()
{
  const int X = 2;

  list<sqr1(X)> mylist1; // OK; sqr1 is constexpr
  list<sqr2(X)> mylist2; // Wrong; sqr2 is not constexpr

  return 0;
}
```

When can I / should I use both, const and constexpr together?
----------------------------

a)**In object declarations** This is never necessary when both keywords refer to the same object to be declared. constexpr implies const.

    constexpr const int N = 5;

is the same as

    constexpr int N = 5;

However, note that there may be situations when the keywords each refer to different parts of the declaration:

```c++
static constexpr int N = 3;
int main()
{
  constexpr const int *NP = &N;
  return 0;
}
```

Here, `NP` is declared as an address constant-expression, i.e. an pointer that is itself a constant expression. (This is possible when the address is generated by applying the address operator to a static/global constant expression.) Here, both constexpr and const are required: constexpr always refers to the expression being declared (here NP), while const refers to int (it declares a pointer-to-const). Removing the const would render the expression illegal (because (a) a pointer to a non-const object cannot be a constant expression and (b) &N is in-fact a pointer-to-constant).

b)**In member function declarations** In C++11, constexpr implies const also for member functions. However, this is likely to change in C++14. According to the current drafts, constexpr will imply const only for objects, not for member functions, due to a proposed change to §7.1.5/8. Hence, a member function declared under C++11 as

    constexpr void f();

will have to be declared as

    constexpr void f() const;

under C++14 in order to still be usable as a const function. Best mark your constexpr member functions as const even now so as to avoid having to change a lot of code later on.




