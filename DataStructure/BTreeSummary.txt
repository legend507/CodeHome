// m阶的B树
1.树中每个结点最多含有m个孩子（m>=2）；

2.除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）； 

3.若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）； 

4.所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，
指向这些结点的指针都为null)；

5.每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：
       a)   Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。 
       b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 
       c)   关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。

// m阶的B+树
1.有n棵子树的结点中含有n-1 个关键字； 

2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 
(而B 树的叶子节点并没有包括全部需要查找的信息)

3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 
(而B 树的非终节点也包含需要查找的有效信息)


B树：有序数组+平衡多叉树；

B+树：有序数组链表+平衡多叉树；

B*树：一棵丰满的B+树。

B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，
B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。

比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。
    B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。

B树比如你的例子中查，17的话，一把就得到结果了，
有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。

另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，
    就会主动换入内存。”


// R树
1.除非它是根结点之外，所有叶子结点包含有m至M个记录索引。作为根结点的叶子结点所具有的记录个数可以少于m。通常，m=M/2。

2.对于所有在叶子中存储的记录（条目），I是最小的可以在空间中完全覆盖这些记录所代表的点的矩形
（注意：此处所说的“矩形”是可以扩展到高维空间的）。

3.每一个非叶子结点拥有m至M个孩子结点，除非它是根结点。

4.对于在非叶子结点上的每一个条目，i是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质2）。

5.所有叶子结点都位于同一层，因此R树为平衡树。

// Spray tree
我们知道AVL树为了保持严格的平衡，所以在数据插入上会呈现过多的旋转，影响了插入和删除的性能，此时AVL的一个变种
伸展树其实就是一种二叉排序树，只是它并不追求树的平衡，而是在每一次插入元素的时候，都通过左旋或右旋使之调整到树根，
这样如果下次再访问这个元素的时候，访问操作就是O(1)了。如果我们要将当前节点移动到根，而不改变二叉排序树的特性。
这样我们用这种数据结构后，算法就变成：将数据插入伸展树中并将数据调整到根，
从根去找左子树的最右节点数据和右子树的最左节点数据，进行差的绝对值比较取小，并将所有的差的绝对值累加即可。
splay,用到了查找树内某结点的前驱，后继和插入操作。

营业额统计
题意就是每读入一个数，在前面输入的数中找到一个与该数相差最小的一个。把所有的差值加起来。
三个操作：插入、求前驱、求后继。

方法1：先将所有数据输入进来，然后将其下标（伴随数组）按照数据的大小排序O(nlog2n)，然后对每一个数，
向两边搜索第一个下标小于自己的数，并计算差值，即他与前驱和后继的差值（绝对值）去较小的。显然TLE。。。

// Treap tree
Treap树算是一种简单的优化策略，这名字大家也能猜到，树和堆的合体，其实原理比较简单，
在树中维护一个“优先级“，”优先级”采用随机数的方法，但是”优先级“必须满足根堆的性质
从树中我们可以看到：
①：节点中的key满足“二叉查找树”。
②：节点中的“优先级”满足小根堆。

