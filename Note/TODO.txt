// Q: 每个任务之间有dependency，怎么安排任务顺序，使得执行任务i的时候，所有被depend的任务已经执行过了。

A: 1. 拓扑排序 2. PERT网络 3. 建筑施工网络规划问题 4. 做邻接矩阵，每次删除出度为零的节点

----------------------------------------------------------------------------------------------------------
// Q: 有两个纯文本文件，其中一个较大，大约上万行，每行是一个具体的域名，比如wudaokou.haidian.beijing.com。
//    另外一个较小，大约一千多行，每行是一个大域名，比如beijing.com。现在想找到一个较快的算法，
//    迅速判断小文件中的大域名清单是否能涵盖大文件中的所有域名。 

A:  追求算法效率可用trie，域名倒序，然后砍节点。追求编码简单就先reverse域名再排序，然后用binary search删区间.

bool covered(const vector<string>& filters, const string& line){
  typedef vector<string>::const_iterator Iterator;
  Iterator filter = lower_bound(filters.begin(), filters.end(), line);
  if (filter != filters.end() && *filter == line)
    return true;
  if (filter != filters.begin())
  {
    --filter;
    if (line.size() >= filter->size()
        && equal(filter->begin(), filter->end(), line.begin()))
      return true;
  }
  return false;
}

int main(int argc, char* argv[])
{
  if (argc == 3)
  {
    vector<string> filters;
    {
      ifstream in2(argv[2]);
      string filter;
      while (getline(in2, filter))
      {
        reverse(filter.begin(), filter.end());
        if (filter[filter.size()-1] != '.')
          filter.push_back('.');

        filters.push_back(filter);
      }
    }
    sort(filters.begin(), filters.end());

    {
      ifstream in1(argv[1]);
      string line;
      while (getline(in1, line))
      {
        reverse(line.begin(), line.end());
        if (line[line.size()-1] != '.')
          line.push_back('.');
        
        if (!covered(filters, line))
        {
          cout << "remain " << line << '\n';
        }
      }
    }
  }
}

-------------------------------------------------------------------------------------------------------------------
Q: 给定二叉树，求只有一个child的节点数

def count_one_child_node(btree):
    count = 0
    queue = []
    if btree != None:
        queue.append(btree)

        while queue:
            current = queue.pop(0)
            #print current.data
            if current.left_node != None and current.right_node == None:
                count += 1
                queue.append(current.left_node)
            elif current.left_node == None and current.right_node != None:
                count += 1
                queue.append(current.right_node)
            elif current.left_node and current.right_node:
                queue.append(current.left_node)
                queue.append(current.right_node)

    return count

----------------------------------------------------------------------------------------------------------------
Q: 给个数组，打乱了，比如：索引 0 1 2 3 4；值 3 2 1 4 0 。数组的值是下次跳的索引位置，
   这样的话数组有环，比如 0 -> 3 -> 4 -> 0 1 -> 2 -> 1， 求最长环的长度。

A: Union-Find.
----------------------------------------------------------------------------------------------------------------
Q: 给定一个大整数N，有如下的初始有序序列位于[0, N - 1]之间（见图）。请设计一个数据结构保存这个初始序列，
   然后写一个函数，接受一个input参数x, 满足0 <= x <= N - 1。 
    1) 假如x在该结构中不存在，出错处理； 
    2) 假如x在该结构中存在，返回x之后第一个不存在的数，并把该数写入结构中

例如N=100， 有如下的序列 
[0 1] [4, 5, 6] [9 10 11] [20] [90] [95 96] [98 99]
x = 8, error
x = 5, return 7, 
[0 1] [4, 5, 6 7] [9 10 11] [20] [90] [95 96] [98 99]
x = 95, return 97,
[0 1] [4, 5, 6] [9 10 11] [20] [90] [95 96 97 98 99]
x = 96, error.

A: 1.线段树， 2.bitmap， 3.B tree, 4.用两个vector分别保存每个区间的最大最小值 用二份查找到查询数所在区间

----------------------------------------------------------------------------------------------------------------
Q: 在一个大串中查找和另外一个字符串是anagram的子串。比如，GetAnagram("abcdbcsdaqdbahs'', "scdcb'') ==> "cdbcs''
    TopCoder -- Anagrams problem

A: 1. 一个长26的数组记录子串每个字符出现次数，大串中遍历一次，遇到相同的字符就在数组中-1，
      如果某字符计数已经是0就从下个位置重新开始，直到所有字符的计数刚好为0就找到匹配
   2. 可以这样试试，先将子串的字符加起来，得到一个和。然后在母串中找等于该和的子串。
      但是等于该和的子串不一定就是要找的子串。也就是还得检查一遍
   3. 对后面一个串进行hash，源串中用两个快慢指针（两指针见长度固定）。每次匹配完，检查是否所有元素全部匹配。
      时间复杂度O(M*N) 空间复杂度为O(2*N) 
