Q:输入数组[a1,a2,...,an,b1,b2,...,bn]，构造函数，使得输出为，[a1,b1,a2,b2,...,an,bn]，注意：方法要是in-place的。

通过观察输入输出的格式，直接通过将b1进行交换，直至目标的位置，其他元素也如此操作。直到完成变换。如下的过程：
a1 a2 a3 a4 b1 b2 b3 b4
确定b1的位置，b1要和前面3个元素依次交换。
a1b1a2a3a4b2b3b4
确定b2的位置，b2要和前面的2个元素一次交换，同样为了保证in-place。注意交换次数少了一次。
a1b1a2b2a3a4b3b4
依次确定b3和b4的位置，b4是最后的元素，不需进行交换，b3需要交换一次。
a1b1a2b2a3b3a4b4
通过上面的分析，则整体的交换次数，3+2+1=6，不失一般性(n-1)+…+1，时间复杂度O(n^2)。

特别的方法同样针对上面的例子：
第一步：交换最中间的一对元素，得到
a1a2a3b1a4b2b3b4
第二步：交换最中间的两对元素，得到
a1a2b1a3b2a4b3b4
第三步：交换最中间的三对元素，得到
a1b1a2b2a3b3a4b4
完毕，得到结果。
在上面的交换中，交换的次数分别为1,2,3，推而广之，1,…,n-1，则时间复杂度仍旧是O(n^2)的。

in-place的O(n)方法这个问题，是存在O(n)时间复杂度的in-place算法的。但是，并不是很好理解。
首先，对2n=3^k - 1的情况下，k是整数。这时候可以通过几个cyclic shift解决。
每个cycle的起始位置是3^i, i=0,1,...,k-1. cycle里面元素下标的符合这样的模式(3^i×2^j) mod (2n+1)
举例说明：k=2时，2n=8.
假设一个数列是[1，2，3，4，5，6，7，8]
那么这几个cycle是
i=0, 3^i=1, [1,2,4,8,16,32] mod 9 = [1,2,4,8,7,5]
i=1， 3^i=3, [3,6] mod 9 = [3,6] 
显然这些cycle都是闭合的，比如对[1,2,4,8,7,5]， 5×2 mod 9 = 1， 对[3,6] 6×2 mod 9 = 3

下面做这两个cyclic shift
做完第一个后：
[1，2，3，4，5，6，7，8] -> [5，1，3，2，7，6，8，4]
做完第二个后：
[5，1，3，2，7，6，8，4] -> [5，1，6，2，7，3，8，4]
搞定。

其次对2n！=3^k - 1的情况下，找一个最大的m，m满足2m=3^k - 1并且m 比如假设n=6，那么m=4.
假设一个素列A=[1，2，3，4，5，6，7，8，9，10，11，12]
首先A[m+1,...,n+m]做一个距离为m的右循环。
也就是[5,6,7,8,9,10]做一个距离为m的右循环，变成[7,8,9,10,5,6]
做完这个循环，[1，2，3，4，5，6，7，8，9，10，11，12]->[1，2，3，4，7，8，9，10，5, 6, 11，12]
然后对前2m项，做1的操作，[1，2，3，4，7，8，9，10，5, 6, 11，12]->[7，1，8，2，9，3，10，4，5, 6, 11，12] 
然后对于下的2*(n-m)项[5，6，11，12]递归操作。
-------------------------------------------------------------------------------------------------------------
