/*
//排序只有1，2，3三个元素的数组，不能统计1，2，3的个数。

1. p1从左侧开始，指向第一个非1的数字；p3从右侧开始，指向第一个非3的数字。
        1. p2从p1开始遍历，如果是2，p2继续遍历，直到p2遇到1或者3
        2. 如果遇到1，则和p1进行交换，然后p1向右，指向第一个非1的数字
        3. 如果遇到3，则和p3进行交换，然后p3向左，指向第一个非3的数字
		重复上面的步骤，直到p2在p3的右侧结束。
2. 思路来自快排的划分部分，快排的划分部分：给定pivot，然后将数据划分为<=pivot和>pivot两部分。
这样，三个数字时，需要两次划分：
        1. 第一次，用1作为pivot,划分1到最左边；
        2. 第二次，用2作为pivot，划分2到左边，则得到整体的排序
3. 我们将1，2，3，替换为互质的2，3，5
之后，乘起来得到的900.这900里，除以2，有多少个2，就有多少个1；
然后除以3，有多少个3，就有多少个3对应的2；然后除以5，有多少个5，就有多少个5对应的3。
*/
void array_sort_v1(int arr[], int len){
	int* p1 = arr;
	int* p3 = arr + len - 1;
	int* p2 = p1;

	while (p2 <= p3){
		while (*p1 == 1)
			++p1;
		while (*p3 == 3)
			--p3;

		p2 = p1;
		while (*p2 == 2)
			++p2;
		if (*p2 == 1){
			swap(*p1, *p2);
		}else{
			swap(*p2, *p3);
		}
	}

	if (*p2 < *p3){
		swap(*p2, *p3);
	}
}
