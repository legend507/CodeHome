/*
Q:一根绳子，长度为n米。将其切成几段，每一段的长度都是整数。
请给出一种切法，使得切成的各段绳子之间的乘积是最大的。注意，最少要切一下的
*/

/*
方法1： 这个题目如何一步一步的分析呢？不管切几段，总有第一段，第二段…等等。第一段的长度有哪些选择呢？
可以是1、2、3...一直到n-1（至少要切一下），我们用max_prod(n)表示长度为n的绳子的切法中，乘积最大的值。那么：​
        1. 当第一段长度为1时，最大的乘积为：max(1×max_prod(n-1), 1×(n-1))​
        2. 当第一段长度为2时，最大的乘积为：max(2×max_prod(n-2), 2×(n-2))​
        3. …​
        4. 当第一段长度为n-1时，最大的乘积为：(n-1)*1=n-1​

上面为什么是取max呢？注意，题目中的要求，至少是要切一下的。这样，从上面的分析中得出，递归的表达式，设第一段绳子的长度为i，
取值范围为[1,n-1]，则，对于每一个i，有最大乘积为:max(i×(n-i),i×max_prod(n-i))。然后对所有的i，求的最大值，就是最终的答案。​
这个题目到这里完了么？看过我们以前分析的同学，很快就能想到，进而查看，这些子问题中是否有重复的，如果有，
则可以采用动态规划的方法进行算法改进。而查看是否有重复递归子问题，一个比较好的方法，就是在纸上画出递归树，
然后是否有重复的递归子问题。就一目了然了。这个题目是比较明显的，同学们可以尝试自己在纸上画画，练习一下。​
既然，我们已经明确了重复的递归子问题，然后呢？
相信专门学习过动态规划专题的同学，都会记得这样的一句话：“自顶向下的分析问题，自底向上的解决问题”，大概类似，
可能并不是原话。自底向上解决问题的意思就是先解决小问题，然后依据这些小问题的结果，再解决一批问题，依次直至解决整个问题：​
        1. 当绳子的长度为1的时候，忽略，不能切​
        2. 当绳子的长度为2的时候，切一刀，max_prod[2]=1×1​
        3. 当绳子的长度为3的时候，切一刀，max_prod[3]=1×2​
        4. 当绳子的长度为4的时候，依赖前面每一个长度的切法，并且，第一个长度从2开始。​
        5. …​

这个，状态转移方程可以表示为:max_prod[i]=max((i-j)×j, j×max_prod[i-j])，其中j的范围是[1,i/2]。
显然，动态规划方法的时间复杂度为O(n^2)，空间复杂度为O(n)。​
这个问题，到这里，已经挺不错的。不过，还没完，这个题目是有更加巧妙的方法的。
*/
int max_prod(int* dp, int index, int len)
{
	if (index < 1 || index > len)
		return 1;

	if (dp[index] == 0)
	{
		dp[index] = max((len-index)*index, index*max_prod(dp, len-index, len));
	}

	return dp[index];
}

int max_length(int len)
{
	int* dp = new int[len];
	int max_len = 0;

	if (dp != NULL)
	{
		memset(dp, 0, sizeof(int));
		dp[1] = 1;
		dp[2] = 1;
		dp[3] = 2;
		for (int i = 1; i < len; i++)
			max_prod(dp, i, len);
	
		for (int i = 1; i < len; ++i)
		{
			if (dp[i] > max_len)
				max_len = dp[i];
		}

		delete[] dp;
	}

	return max_len;
}

/*
方法2：只需要将长度n表示为3x+2y=n，并且3尽可能的多，这样的3^x+2^y是最大的。
不得不赞叹，这确实是一个很巧妙的方法。大家可以通过例子，验证几个。为什么只有3和2呢？
长度为4的，就是2×2，5以上的，都可以分解为3x+2y，并且3^x+2^y>5以上的数字。
*/
