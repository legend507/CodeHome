有一座金字塔，从上到下，第一层有一个杯子、第二层有两个杯子，依次类推。对杯子进行编号，有如下的形状：
   1
 2   3
4   5   6
每个杯子的容量为C升，从塔顶倒下L升水，当1号杯子满了之后，会等量溢出到2号和3号杯子。
当2号和3号满了，2号溢出到4号和5号，3号溢出到5号和6号，注意5号接受来自两个杯子的水。依次类推。
给定C和L，请问，第n杯里有多少水。

这个类型的题目，关键点就是明了水倒下来的过程。我们这里做简单的分析， 假设L>C, 如果L
金字塔深度011222杯号123456A索引012345观察上面的表格，我们会发现，一个规律，i号杯深度为h，则i号中溢出的水，将平分进入：
	* i + h + 1
	* i + h + 2
比如，文章开始的图中，3号杯进入5号和六号，3号杯的h为1，则
	* 5 = 3 + 1 + 1
	* 6 = 3 + 2 + 2
利用这个技巧，可以在数组中存储树形的金字塔，并且可以很方便的找到孩子节点。
计算出所有的A[i]之后，要得到最后的答案，还有一部之遥。即：
	* A[i] >= C ? C : A[i]

--------------------------------------------------------------------------------------------------------------
//一个数组A[1...n]，满足A[1]>=A[2], A[n] >= A[n-1]。A[i]被成为波谷，意味着：A[i-1] >= A[i] <= A[i+1]。
//请给出一个算法，找到数组中的一个波谷。O(n)的方法，是很直接，有更快的方法么？
找到数组的mid元素，mid有几种情况：
	* 如果A[mid-1]>=A[mid] && A[mid+1]>=A[mid]，找到波谷；
	* 如果A[mid-1]<=A[mid]<A[mid+1]，right=mid，在左侧继续找；
	* 如果A[mid+1]<=A[mid]<A[mid-1]，left=mid，在右侧继续找；
	* 如果A[mid-1]<A[mid] && A[mid+1]<A[mid]，任意一侧都可以，任意一侧，都必将存在波谷。

--------------------------------------------------------------------------------------------------------------
//排序只有1，2，3三个元素的数组，不能统计1，2，3的个数。
1. p1从左侧开始，指向第一个非1的数字；p3从右侧开始，指向第一个非3的数字。
	1. p2从p1开始遍历，如果是2，p2继续遍历，直到p2遇到1或者3
	2. 如果遇到1，则和p1进行交换，然后p1向右，指向第一个非1的数字
	3. 如果遇到3，则和p3进行交换，然后p3向左，指向第一个非3的数字
重复上面的步骤，直到p2在p3的右侧结束。
2. 思路来自快排的划分部分，快排的划分部分：给定pivot，然后将数据划分为<=pivot和>pivot两部分。
这样，三个数字时，需要两次划分：
	1. 第一次，用1作为pivot,划分1到最左边；
	2. 第二次，用2作为pivot，划分2到左边，则得到整体的排序
3. 我们将1，2，3，替换为互质的2，3，5
之后，乘起来得到的900.这900里，除以2，有多少个2，就有多少个1；
然后除以3，有多少个3，就有多少个3对应的2；然后除以5，有多少个5，就有多少个5对应的3。

-----------------------------------------------------------------------------------------------------------
//给定一个数组，数组中只包含0和1。请找到一个最长的子序列，其中0和1的数量是相同的。
//例1：10101010 结果就是其本身。
//例2：1101000 结果是110100
原来是0和1的串，我们将0都换为-1。这样题目目标就变成，找到一个最长的子串，子串数字和是0。
如果DP[i]==DP[j]，i 一种方法，我们用map保存DP的值到位置的映射，如下表：
上面的这个思路，时间复杂度是O(n),空间复杂度也是O(n).
-----------------------------------------------------------------------------------------------------------

//给定只包含正数的数组，给出一个方法，将数组中的数拼接起来，得到的数，是最大的。 
//例如： [4, 94, 9, 14, 1] 拼接之后，所得最大数为：9944141
一次排序，就得到了结果。给定例子：5,54,56
	1. 比较5和54，实际上就是比较545和554哪个大
	2. 比较5和56，实际上就是比较556和565哪个大
	3. 比较54和56，实际上就是比较5456和5654哪个大
那我们对快排程序做一下变化，当两个数字a和b进行比较时，比较的是ab和ba两个数字的大小即可。
只是比较发生了变化，剩下的和快排都是一样的。

--------------------------------------------------------------------------------------------------------------
//给定一批查询日志，数量为n。其中，有的查询出现了多于n/3次，请在线性时间内，找到所有满足条件的查询。

1.采用hashmap进行计数，O(n)的空间，O(n)的时间
2.进行排序，O(nlogn)
3.快速选择算法，这个也可以做到O(n)的时间。
4.我们申请一个大小为m的map，开始遍历查询日志，如果：
  1. 遇到一个不在map中的查询，则插入map中，并且将值设置为1（相当于新落下一个方块）
	2. 遇到一个在map中的查询，则将map中，该查询对应的值加1（相当于在已有的方块上又多加了一个）
当map中的查询个数等于m时，则对map中所有查询的值减一（相当于砌满了一层，就会消掉）。
直到遍历完毕查询日志，map中还存在的查询，就是我们要找的查询的备选。

-------------------------------------------------------------------------------------------------------------------
//大家都知道facebook用户都是双向的好友，a是b的好友，那么b一定是a的好友，现在给定一个用户列表，
其中有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，并且每组内的用户，互相都不是好友。
如果能，请给出这个划分。
例子1： 用户：{1, 2, 3} 好友关系：1-2， 2-3 划分：{1,3} {2}
例子2： 用户{1,2,3,4} 好友关系：1-2， 2-3， 3-4，4-1 划分：{1, 3}{2, 4}

相对而言，今天的面试题目比较简单。因为建模的部分，已经在题目中给出了。稍想一下，图分割的问题。
facebook的好友关系是双向的，意味着是无向图（新浪微博，twitter都是有向图）。然后，要把图划分为两组，这两组满足什么条件呢？
组内没有边，组间有边。这显然就是一个二分图。
那问题很明显了，就是facebook好友关系构成的图，是否是一个二分图？如果是，请找到这个划分。就是二分图判断+找到一个划分即可。
根据二分图的特性，一条边上的两个点，肯定是属于不同的组。如果它们出现在同一个组中，肯定就不是二分图了。
怎么判断，一条边上的两个点，分属于不同的组呢？我们需要遍历图，如果找到一条边，两个节点，都在同一组，则不是二分图；
如果图遍历完成之后，没有找到这样的边，则是二分图。我们在遍历的过程中，我们需要区分，一条边的两个节点分属于不同的组，
这里我们用到了染色法。核心思想如下：
从某一个点开始，将这个节点染色为白色，并且开始广度优先遍历，找到与其相邻的节点，如果是二分图，相邻节点的颜色都应该不同。
如果是黑色，则不变；如果是无色，则染成黑色；如果是白色，也就是同色，程序退出。
当图遍历完毕时，没有相邻节点同色的，则是二分图，标记为白色和黑色的两组就是一个划分。

-----------------------------------------------------------------------------------------------------------------------
//Q:Describe an algorithm that takes an unsorted array of axis‐aligned rectangles and
//returns any pair of rectangles that overlaps, if there is such a pair. Axis‐aligned
//means that all the rectangle sides are either parallel or perpendicular to the x‐ and
//y‐axis. You can assume that each rectangle object has two variables in it: the x‐y
//coordinates of the upper‐left corner and the bottom‐right corner.

Good Answer: Create a sorted array of the x coordinates of the left and right edges of
the rectangles. Then, use a "scanline" to move from left to right through the
rectangles. Keep a binary search tree containing the y coordinates of the top and
bottom edges of the rectangles that overlap the scanline. For each element of the
array, check whether it is a left or right edge. If it is a right edge, remove the
corresponding top and bottom edges from the BST. If it is a left edge, search the BST
for rectangles that overlap the current rectangle; if there is one, return the overlap.
Then, add the y coordinates of the top and bottom edges of the rectangle to the BST.
The search takes O(n log n) time, since it takes O(n log n) time to sort the rectangles
and each of the 2n iterations takes O(log n) time.

----------------------------------------------------------------------------------------------------------

//Q: 给你一个数组，它有N个8-bit整数， （比如，从0到255）， 和M个子数组，
//[i, j] （每个子数组由两个下标 i 和 j 确定，0 <= i <= j < N）。对每个子数组，找到平均值和中值。
A: 原数组为b「」，新建一个n位整数数组a「」，a「i」的值为b「0」到b「i」的累加值。
求平均值和中直操作是o（1），构造数组是哦（n）。算法复杂度o（n）
上述方法求平均值可以是O（1），但中值是怎样求？感觉还要有一个数组c[N][256],
c[i][k]里面放b[0]到b[i]中k值出现的次数，对任何i j 中值保证在O(256)时间里求出。


// Q: 每个任务之间有dependency，怎么安排任务顺序，使得执行任务i的时候，所有被depend的任务已经执行过了。

A: 1. 拓扑排序 2. PERT网络 3. 建筑施工网络规划问题 4. 做邻接矩阵，每次删除出度为零的节点

----------------------------------------------------------------------------------------------------------------
Q: 给定一个大整数N，有如下的初始有序序列位于[0, N - 1]之间（见图）。请设计一个数据结构保存这个初始序列，
   然后写一个函数，接受一个input参数x, 满足0 <= x <= N - 1。 
    1) 假如x在该结构中不存在，出错处理； 
    2) 假如x在该结构中存在，返回x之后第一个不存在的数，并把该数写入结构中

例如N=100， 有如下的序列 
[0 1] [4, 5, 6] [9 10 11] [20] [90] [95 96] [98 99]
x = 8, error
x = 5, return 7, 
[0 1] [4, 5, 6 7] [9 10 11] [20] [90] [95 96] [98 99]
x = 95, return 97,
[0 1] [4, 5, 6] [9 10 11] [20] [90] [95 96 97 98 99]
x = 96, error.

A: 1.线段树， 2.bitmap， 3.B tree, 4.用两个vector分别保存每个区间的最大最小值 用二份查找到查询数所在区间

----------------------------------------------------------------------------------------------------------------
Q: 在一个大串中查找和另外一个字符串是anagram的子串。比如，GetAnagram("abcdbcsdaqdbahs'', "scdcb'') ==> "cdbcs''
    TopCoder -- Anagrams problem

A: 1. 一个长26的数组记录子串每个字符出现次数，大串中遍历一次，遇到相同的字符就在数组中-1，
      如果某字符计数已经是0就从下个位置重新开始，直到所有字符的计数刚好为0就找到匹配
   2. 可以这样试试，先将子串的字符加起来，得到一个和。然后在母串中找等于该和的子串。
      但是等于该和的子串不一定就是要找的子串。也就是还得检查一遍
   3. 对后面一个串进行hash，源串中用两个快慢指针（两指针见长度固定）。每次匹配完，检查是否所有元素全部匹配。
      时间复杂度O(M*N) 空间复杂度为O(2*N) 
