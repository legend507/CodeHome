Q:给定平面上的两个格点P1(x1,y1)，P2(x2,y2)，在线段P1P2上，除P1、P2外，一共有多少个格点？格点定义为x和y都是整数的点。

这是一个简单的题目，方法比较多了，比如，首先求的直线的方程式：y=ax+b。然后在x轴，从x1+1开始，到x2-1结束，
将每一个整数带入上面的方程式，得到y值。如果y满足y1<y<y2，则找到一个格点，遍历完毕之后，得到全部的格点。
时间复杂度，O(|x2-x1|)。也是比较快的。还有更暴力的方法，时间复杂度为O(|x2-x1|*|y2-y1|)，
从这个大家可以看出来，完全是遍历每一个整数点，看是否落在直线上。
那么有没有更快的方法呢？这个题目实际上是求|x1-x2|和|y1-y2|的最大公约数，格点数目就是最大公约数减取1。
大家可以画画图，验证这个方法。最好是画一个棋盘。
大家还记得最大公约数是怎么计算的么？辗转相除法。设a和b的最大公约数为gcd(a,b)，则gcd(a,b) = gcd(b, a%b)。
公式比较简单，改如何分析时间复杂度呢？是否更快呢？
我们假设a>b，则有如下的过程
gcd(a, b) = gcd(b, a%b) = gcd(a%b, b % (a % b)) …
一直递归到结束，gcd(x, 0) = x。
	* 当b>a/2时，a % b = a - b < a / 2
	* 当b<a/2时，a % b < b < a / 2
每一次新的递归，第一个参数都要小于原来的一半，所以，估计其时间复杂度在O(log max(a,b))以内，
这里的a和b分别为|x1-x2|和|y1-y2|。比线性的解决方案要快。
---------------------------------------------------------------------------------------------------------------------
Q:为了修理栅栏，需要将很长的木板锯为N块，长度分别为L1,L2...LN。锯断一块儿木板，需要一定的开销，开销记为木板的长度。
例如，长度为21的木板，锯为三块，长度分别为5，8，8。如下按照如下的顺序据断：
	* 首先锯断21为13和8两块儿，开销为21
	* 然后锯断13为8和5两块儿，开销为13
总的开销为34。但也可以按照如下的顺序：
	* 首先锯断21为16和5两块儿，开销为21
	* 然后锯断16为8和8两块儿，开销为16
总的开销为37。比34要大。问题是，给定N，以及每一块儿的长度。如何保证最小的开销。尽量采用高效的方法。

这个题目，要如何分析？这切锯成N块的方法太多了。如何入手呢？其实，题目中的两个例子，都可以表明，
我们可以将切割的过程用二叉树表示：
            21
        13      8
     8      5
以及
             21
          16      5
       8      8
根据上面两棵二叉树，得到开销的计算方法：
	* 第一棵树，开销34 = 8 * 2 + 5 * 2 + 8 * 1 = 34
	* 第二颗树，开销37 = 8 * 2 + 8 * 2 + 5 * 1 = 37
也就是所有的叶子节点的长度乘以深度。叶子节点，就是各个木块儿的长度。从上面的式子，我们可以得出，要想开销最小，
树的高度是不变的，那就一定要越短的木板，深度越深，即可。而且，因为一次锯开，肯定是两块儿，
所以，要保证整个开销最小，则最短的和次短的木板一定是兄弟，这样，可以递归使得，父亲节点的开销也是最小的。
这样，求的最小开销就很简单了，去最短和次短木板，加起来，得到一个开销，假设L1是最短的，L2是次短的。
则递归处理(L1+L2)以及剩下的木板即可。这个复杂度是O(N^2)的。

那么是否有更高效的方法呢？上面的方法，是从底向上计算的。锯的时候，如何做呢？从最长的开始，每次都把最长的锯掉。
这样排序O(NlogN)。从最大的开始锯。解决。
----------------------------------------------------------------------------------------------------------
Q:有N个木桩，高度分别为1到N。你现在要将木桩排列为一行，当你从左边看的时候，只看到L个木桩
(因为，一些高的木桩会挡住矮的木桩)；从右边看时，只看到R个木桩。给定N、L、R，你该如何排列木桩呢？
例1：N=3,L=2,R=1，可行的排列方案只有{2,1,3}。
例2：N=3,L=2,R=2，可行的排列方案有{1,3,2}{2,3,1}

开始排列木桩的时候，应该如何选取第一根木桩呢？一个很直接的选择就是先确定最高的木桩的位置，也就是N。
因为，无论从左到右，还是从右到左看，都要到最高停下来。
确定了最高的木桩之后，无论从哪一边看，都至少有一个木桩。接下来，该如何处理？想必大家已经想到了，开始递归呗。
左右两边，也同样是先确定最高的木桩的位置，依次递归下去。
构造的方法，是比较简单地。但，往往这个时候面试题并没有结束。面试官，会进一步问：给定NLR，有多少种排列木桩的方法呢？
从一个构造问题，转变为一个计数的问题。该如何做呢？方法仍旧是递归，我们尝试写出递归表达式。
假设，b(N,L,R)表示排列方案的总数。f(N, L)表示N个木桩，排列得到从左边能够看到L个木桩的方案总数。我们从f的递归形式入手分析。
首先，f(N,N)=1。从左到右，从低到高排列，只有一个方案。
然后，f(N,M)=0,当N<M时。显而易见。
其次，f(N,1)=(N-1)!。当只看到一个木桩的时候，即最高的木桩排在最左边，其他的木桩无论怎么排列都可以。
再次，假设最高的木桩放在从左边开始的第k个位置，则，我们要在剩下的N-1个木桩里面，选取k-1个木桩放在最高木桩的左边，
并且，找到能看到L-1个木桩的方案数(因为最高的木桩一定能看见，所以是L-1个)，此时剩下的N-K个木桩，可以任意排列，
得到递归表达式如下：
f(N, L) = sum_{L<=k<=N} (N-1 选择 k-1) * f(k-1, L-1) * (N-k)! 
这个式子，是仅仅考虑了总左边看到L个柱子的情况，再需要考虑，从右边看，有R根柱子的方案呢？
其实很简单了，剩下的N-k个柱子，不要任意排列，要保证从右边能够看到R-1个柱子即可。所得递归式如下：
b(N,L,R) = sum_{L<=k<=N-R+1} (N-1 选择 k-1) * f(k-1, L-1) * f(N-k,R-1) 

------------------------------------------------------------------------------------------------
Q:X和Y都是只有0和1组成的字符串。D(X,Y)称为模糊距离，定义如下：首先删除X和Y从头开始的公共子串
然后将X和Y剩下部分的长度相加得到模糊距离
例如D(1000,1111)，首先，删除子串“1”，然后剩下“000”和“111”长度都是3，相加为6，则
D(1000,1111)=6。
例如D(101,1100)，首先删除公共子串“1”，然后剩下"01"和"100"长度分别为2，3，相加为5，则
D(101,1100)=5。
问题是，给定n个只有0和1的字符串，如：
1111
1000
101
1100
...
请找到最大的模糊距离，字符串总数为n，字符串最长为m。

直接想来，对于每一个01字符串，与其他的每一个01字符串进行模糊距离的计算，时间复杂度是O(nm)，遍历完n个字符串，
总的时间复杂度是O(n^2*m)。这个我们可以称为暴力法。
如何改进上面的方法的，主要是指缩小时间复杂度。一个非常通用的方法，就是以空间换时间。如何换呢？
对于模糊距离的第一个条件，我们想到什么呢？公共前缀，不知道同学们，联想到树形结构：trie树没有。
例如：给定000、001、0010，我们构造如下的trie树。

构造过程中，1为左子树，0为右子树。模糊距离的第一个条件是，去掉公共前缀，则计算时，两个字符串，要有公共前缀，
也就意味着，只需要考虑开始分叉的节点，左右子树，可以有一个没有。这样，我们考虑第一个分叉的节点：0，
然后可以计算第二部分了，如何计算剩下长度相加呢？
尤其，为了找到模糊距离的最大值，我们求得当前节点的左子树的最大深度以及右子树的最大深度，两者相加，
及得到一个模糊距离，为3。然后考虑1节点，右子树为空，则模糊距离为1。综合，最大的模糊距离为3。
这里有一个小小的技巧，构建的过程中，可以在节点中，存储左右子树的高度，并随着加入新的字符串，更新左右子树的高度。
总的时间复杂度为O(nm)。 根据上例，存储的左右子树的高度值变化如下 (left_height, right_height):
	* left_height: 左边子树的高度
	* right_height: 右边子树的高度

-------------------------------------------------------------------------------------------------------------------
Q:盒子中有n张卡片，上面的数字分别为k1,k2,...,kn。你有4次机会，每抽一次，记录下卡片上的数字，再将卡片放回盒子中。
如果4个数字的和等于m。则你就赢得游戏，否则就是输。直觉上，赢的可能性太低了。请你给出程序，判断是否有赢的可能性。

这个题目最直接的方法就是四重循环遍历，n^4的时间复杂度，比较恐怖，但确实一个很好的起点。
不用觉得很丢人，只要我们持续改进即可。
假设a，b，c是k1到kn中的三个数字，是否存在d使得，a+b+c+d=m？d在k1到kn中。和题目中的意思是一样的，变换等式如下：
d = m - a - b - c
如果满足上式，就是说，要在k1到k2中查找d，即：查找m - a - b - c，找到就存在；找不到，就是不存在。
查找有线性查找，二分查找等。四重循环最内一层循环，可以认为是线性的查找，如果想更快一些，可以应用二分查找，
而二分查找需要k1到kn是排序的，则先对n个数字进行排序，时间复杂度O(nlogn)。
然后最内一层循环，改为二分查找，时间复杂度为O(n^3logn)。所以总的时间复杂度为O(n^3logn)。

经过上面的分析，我们可以得到启发，既然可以提出一个d，那么就可以再提出一个c。将a+b+c+d=m转换为c+d=m-a-b。
这样，我们可以枚举k1到kn的两个数的和，然后对n2个和，进行排序，时间复杂度为o(n^2logn)。
然后遍历n^2个和，设每一个和为pair，查找是否存在m-pair，同样二分查找，时间复杂度为O(n^2logn)。总的时间复杂度为O(n^2logn)。
--------------------------------------------------------------------------------------------------------------------
Q: 求正数数组内和为指定数字的合并总数
比如[5, 5, 10, 2, 3] 合并值为 15 : 有4种 ： (5 + 10, 5 + 10, 5 + 5 + 2 + 3, 10 + 2 + 3)

我们设定f(index，sum)表示数组从index开始到结束组成的sum的总数。那么，f(index, sum)可以表示为什么呢？ 
我们这个题目，就是要最终求得f(0, 15)，从头开始分析，最终组成的和为15的可能组合中，可能包含第0个元素，也可能不包含, 
原始数组为A：
	* 当包含第0个元素时，剩下的表示为f(1, 15-A[0])
	* 不包含第0个元素时，剩下的表示为f(1, 15)
则，f(0, 15) = f(1, 15) + f(1, 15 - A[0])。依次递归。递归的终止条件是什么呢？对于f(index,sum):
	* 当和小于等于0的时候，f(index,sum) = 0
	* 当和小于sum的时候， f(index, sum) = f(index + 1, num);
	* 当和等于sum的时候，f(index, sum) = 1 + f(index + 1, sum);
但是，上面的条件，并没有使用题目中，数组全是正数，也就是存在负数也可以。如果仅仅是正数，后两个改为：
	* 当和小于sum的时候， f(index, sum) = 0;
	* 当和等于sum的时候，f(index, sum) = 1;
有一个条件，我们没有使用，也意味着提升的空间。
可是，上面的方案，时间复杂度是指数级。怎么做一些改进呢？一般在对一个算法进行优化的时候，有哪些思路呢？
尤其是这种时间很恐怖的？我想很多同学都有这个经验，就是空间换时间。
大家可以想象动态规划的思想，大家看如下的状态转移方程：
dp[n][m]=dp[n-1][m]+dp[n-1][m-num[n-1]]
dp[n][m]表示前n个元素组成和为m的情况数。初始化dp[0][0]=1，其他为0。
写出状态转移方程，大家也就明白了，为何要求全是正数了吧，直白一些，数组的索引，怎么可能为负呢？
在计算的过程中，将和的情况保存下来，用空间换时间，整个算法的时间复杂度为O(n*m)，不再是指数级。
-------------------------------------------------------------------------------------------------------------
Q:给定无序数组A，在线性时间内找到i和j，j>i，并且保证A[j]-A[i]是最大的。

这个题目是比较简单的。很直接的，对于每一个A[j]，如果知道前面的元素中最小的元素min，则此时相差最大为A[j]-min。
则，假设有一个数组M，M[j]表示[0,j-1]中最小的元素。这个遍历一边A，就可以完成构造M。再遍历一边数组，就可以找到相差最大的。
我们举个例子看看M，以及是否有改进的空间。
就是并不需要一个数组保存最小值，而只需要一个变量即可。
上面的例子不明显，假定A={2,5,1,3,4}，过程如下：
j  A[j]  最小值m   A[j]-m
0   2      2         0
1   5      2         3
2   1      1         0
3   3      1         2
4   4      1         3
最终得到相差最大为3.这个例子，可以找到两个i，j。

---------------------------------------------------------------------------------------------------------
有一座金字塔，从上到下，第一层有一个杯子、第二层有两个杯子，依次类推。对杯子进行编号，有如下的形状：
   1
 2   3
4   5   6
每个杯子的容量为C升，从塔顶倒下L升水，当1号杯子满了之后，会等量溢出到2号和3号杯子。
当2号和3号满了，2号溢出到4号和5号，3号溢出到5号和6号，注意5号接受来自两个杯子的水。依次类推。
给定C和L，请问，第n杯里有多少水。

这个类型的题目，关键点就是明了水倒下来的过程。我们这里做简单的分析， 假设L>C, 如果L
金字塔深度0 1 1 2 2 2
杯号      1 2 3 4 5 6
A索引     0 1 2 3 4 5
观察上面的表格，我们会发现，一个规律，i号杯深度为h，则i号中溢出的水，将平分进入：
	* i + h + 1
	* i + h + 2
比如，文章开始的图中，3号杯进入5号和六号，3号杯的h为1，则
	* 5 = 3 + 1 + 1
	* 6 = 3 + 2 + 2
利用这个技巧，可以在数组中存储树形的金字塔，并且可以很方便的找到孩子节点。
计算出所有的A[i]之后，要得到最后的答案，还有一部之遥。即：
	* A[i] >= C ? C : A[i]

--------------------------------------------------------------------------------------------------------------
//一个数组A[1...n]，满足A[1]>=A[2], A[n] >= A[n-1]。A[i]被成为波谷，意味着：A[i-1] >= A[i] <= A[i+1]。
//请给出一个算法，找到数组中的一个波谷。O(n)的方法，是很直接，有更快的方法么？
找到数组的mid元素，mid有几种情况：
	* 如果A[mid-1]>=A[mid] && A[mid+1]>=A[mid]，找到波谷；
	* 如果A[mid-1]<=A[mid]<A[mid+1]，right=mid，在左侧继续找；
	* 如果A[mid+1]<=A[mid]<A[mid-1]，left=mid，在右侧继续找；
	* 如果A[mid-1]<A[mid] && A[mid+1]<A[mid]，任意一侧都可以，任意一侧，都必将存在波谷。

--------------------------------------------------------------------------------------------------------------
//排序只有1，2，3三个元素的数组，不能统计1，2，3的个数。
1. p1从左侧开始，指向第一个非1的数字；p3从右侧开始，指向第一个非3的数字。
	1. p2从p1开始遍历，如果是2，p2继续遍历，直到p2遇到1或者3
	2. 如果遇到1，则和p1进行交换，然后p1向右，指向第一个非1的数字
	3. 如果遇到3，则和p3进行交换，然后p3向左，指向第一个非3的数字
重复上面的步骤，直到p2在p3的右侧结束。
2. 思路来自快排的划分部分，快排的划分部分：给定pivot，然后将数据划分为<=pivot和>pivot两部分。
这样，三个数字时，需要两次划分：
	1. 第一次，用1作为pivot,划分1到最左边；
	2. 第二次，用2作为pivot，划分2到左边，则得到整体的排序
3. 我们将1，2，3，替换为互质的2，3，5
之后，乘起来得到的900.这900里，除以2，有多少个2，就有多少个1；
然后除以3，有多少个3，就有多少个3对应的2；然后除以5，有多少个5，就有多少个5对应的3。

-----------------------------------------------------------------------------------------------------------
//给定一个数组，数组中只包含0和1。请找到一个最长的子序列，其中0和1的数量是相同的。
//例1：10101010 结果就是其本身。
//例2：1101000 结果是110100
原来是0和1的串，我们将0都换为-1。这样题目目标就变成，找到一个最长的子串，子串数字和是0。
如果DP[i]==DP[j]，i 一种方法，我们用map保存DP的值到位置的映射，如下表：
上面的这个思路，时间复杂度是O(n),空间复杂度也是O(n).
-----------------------------------------------------------------------------------------------------------

//给定只包含正数的数组，给出一个方法，将数组中的数拼接起来，得到的数，是最大的。 
//例如： [4, 94, 9, 14, 1] 拼接之后，所得最大数为：9944141
一次排序，就得到了结果。给定例子：5,54,56
	1. 比较5和54，实际上就是比较545和554哪个大
	2. 比较5和56，实际上就是比较556和565哪个大
	3. 比较54和56，实际上就是比较5456和5654哪个大
那我们对快排程序做一下变化，当两个数字a和b进行比较时，比较的是ab和ba两个数字的大小即可。
只是比较发生了变化，剩下的和快排都是一样的。

--------------------------------------------------------------------------------------------------------------
//给定一批查询日志，数量为n。其中，有的查询出现了多于n/3次，请在线性时间内，找到所有满足条件的查询。

1.采用hashmap进行计数，O(n)的空间，O(n)的时间
2.进行排序，O(nlogn)
3.快速选择算法，这个也可以做到O(n)的时间。
4.我们申请一个大小为m的map，开始遍历查询日志，如果：
  1. 遇到一个不在map中的查询，则插入map中，并且将值设置为1（相当于新落下一个方块）
	2. 遇到一个在map中的查询，则将map中，该查询对应的值加1（相当于在已有的方块上又多加了一个）
当map中的查询个数等于m时，则对map中所有查询的值减一（相当于砌满了一层，就会消掉）。
直到遍历完毕查询日志，map中还存在的查询，就是我们要找的查询的备选。

-------------------------------------------------------------------------------------------------------------------
//大家都知道facebook用户都是双向的好友，a是b的好友，那么b一定是a的好友，现在给定一个用户列表，
其中有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，并且每组内的用户，互相都不是好友。
如果能，请给出这个划分。
例子1： 用户：{1, 2, 3} 好友关系：1-2， 2-3 划分：{1,3} {2}
例子2： 用户{1,2,3,4} 好友关系：1-2， 2-3， 3-4，4-1 划分：{1, 3}{2, 4}

相对而言，今天的面试题目比较简单。因为建模的部分，已经在题目中给出了。稍想一下，图分割的问题。
facebook的好友关系是双向的，意味着是无向图（新浪微博，twitter都是有向图）。然后，要把图划分为两组，这两组满足什么条件呢？
组内没有边，组间有边。这显然就是一个二分图。
那问题很明显了，就是facebook好友关系构成的图，是否是一个二分图？如果是，请找到这个划分。就是二分图判断+找到一个划分即可。
根据二分图的特性，一条边上的两个点，肯定是属于不同的组。如果它们出现在同一个组中，肯定就不是二分图了。
怎么判断，一条边上的两个点，分属于不同的组呢？我们需要遍历图，如果找到一条边，两个节点，都在同一组，则不是二分图；
如果图遍历完成之后，没有找到这样的边，则是二分图。我们在遍历的过程中，我们需要区分，一条边的两个节点分属于不同的组，
这里我们用到了染色法。核心思想如下：
从某一个点开始，将这个节点染色为白色，并且开始广度优先遍历，找到与其相邻的节点，如果是二分图，相邻节点的颜色都应该不同。
如果是黑色，则不变；如果是无色，则染成黑色；如果是白色，也就是同色，程序退出。
当图遍历完毕时，没有相邻节点同色的，则是二分图，标记为白色和黑色的两组就是一个划分。

-----------------------------------------------------------------------------------------------------------------------
//Q:Describe an algorithm that takes an unsorted array of axis‐aligned rectangles and
//returns any pair of rectangles that overlaps, if there is such a pair. Axis‐aligned
//means that all the rectangle sides are either parallel or perpendicular to the x‐ and
//y‐axis. You can assume that each rectangle object has two variables in it: the x‐y
//coordinates of the upper‐left corner and the bottom‐right corner.

Good Answer: Create a sorted array of the x coordinates of the left and right edges of
the rectangles. Then, use a "scanline" to move from left to right through the
rectangles. Keep a binary search tree containing the y coordinates of the top and
bottom edges of the rectangles that overlap the scanline. For each element of the
array, check whether it is a left or right edge. If it is a right edge, remove the
corresponding top and bottom edges from the BST. If it is a left edge, search the BST
for rectangles that overlap the current rectangle; if there is one, return the overlap.
Then, add the y coordinates of the top and bottom edges of the rectangle to the BST.
The search takes O(n log n) time, since it takes O(n log n) time to sort the rectangles
and each of the 2n iterations takes O(log n) time.

----------------------------------------------------------------------------------------------------------

//Q: 给你一个数组，它有N个8-bit整数， （比如，从0到255）， 和M个子数组，
//[i, j] （每个子数组由两个下标 i 和 j 确定，0 <= i <= j < N）。对每个子数组，找到平均值和中值。
A: 原数组为b「」，新建一个n位整数数组a「」，a「i」的值为b「0」到b「i」的累加值。
求平均值和中直操作是o（1），构造数组是哦（n）。算法复杂度o（n）
上述方法求平均值可以是O（1），但中值是怎样求？感觉还要有一个数组c[N][256],
c[i][k]里面放b[0]到b[i]中k值出现的次数，对任何i j 中值保证在O(256)时间里求出。


// Q: 每个任务之间有dependency，怎么安排任务顺序，使得执行任务i的时候，所有被depend的任务已经执行过了。

A: 1. 拓扑排序 2. PERT网络 3. 建筑施工网络规划问题 4. 做邻接矩阵，每次删除出度为零的节点

----------------------------------------------------------------------------------------------------------------
Q: 给定一个大整数N，有如下的初始有序序列位于[0, N - 1]之间（见图）。请设计一个数据结构保存这个初始序列，
   然后写一个函数，接受一个input参数x, 满足0 <= x <= N - 1。 
    1) 假如x在该结构中不存在，出错处理； 
    2) 假如x在该结构中存在，返回x之后第一个不存在的数，并把该数写入结构中

例如N=100， 有如下的序列 
[0 1] [4, 5, 6] [9 10 11] [20] [90] [95 96] [98 99]
x = 8, error
x = 5, return 7, 
[0 1] [4, 5, 6 7] [9 10 11] [20] [90] [95 96] [98 99]
x = 95, return 97,
[0 1] [4, 5, 6] [9 10 11] [20] [90] [95 96 97 98 99]
x = 96, error.

A: 1.线段树， 2.bitmap， 3.B tree, 4.用两个vector分别保存每个区间的最大最小值 用二份查找到查询数所在区间

----------------------------------------------------------------------------------------------------------------
Q: 在一个大串中查找和另外一个字符串是anagram的子串。
   比如，GetAnagram("abcdbcsdaqdbahs'', "scdcb'') ==> "cdbcs''
    TopCoder -- Anagrams problem

A: 1. 一个长26的数组记录子串每个字符出现次数，大串中遍历一次，遇到相同的字符就在数组中-1，
      如果某字符计数已经是0就从下个位置重新开始，直到所有字符的计数刚好为0就找到匹配
   2. 可以这样试试，先将子串的字符加起来，得到一个和。然后在母串中找等于该和的子串。
      但是等于该和的子串不一定就是要找的子串。也就是还得检查一遍
   3. 对后面一个串进行hash，源串中用两个快慢指针（两指针见长度固定）。每次匹配完，检查是否所有元素全部匹配。
      时间复杂度O(M*N) 空间复杂度为O(2*N) 
-----------------------------------------------------------------------------------------------------------------
Q: 请构造程序，找到满足如下条件的最大数：
假设最大数表示为，abcdefghihk..... 每一个字母表示一位，其中
abc，bcd，cde...以此类推，每三个一组，构成的数字是素数，也就是说abc, bcd, cde，等，都是素数，而且这些素数是互不相同的。

我们首先对这个题目进行建模，构造一个有向图G。G中的节点就是三位素数，比如abc，bcd，def都是三位素数，
则他们都是有向图G中的节点。其中，abc和bcd之间有abc指向bcd的边。abc、bcd则与def之间没有边。如此，构造完整G。
大家可以在纸上画一画。所有的三位素数如下：
101, 103, 107, 109, 113,
127, 131, 137, 139, 149, 151, 157, 163, 167, 173,
179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
233, 239, 241, 251, 257, 263, 269, 271, 277, 281,
283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
467, 479, 487, 491, 499, 503, 509, 521, 523, 541,
547, 557, 563, 569, 571, 577, 587, 593, 599, 601,
607, 613, 617, 619, 631, 641, 643, 647, 653, 659,
661, 673, 677, 683, 691, 701, 709, 719, 727, 733,
739, 743, 751, 757, 761, 769, 773, 787, 797, 809,
811, 821, 823, 827, 829, 839, 853, 857, 859, 863,
877, 881, 883, 887, 907, 911, 919, 929, 937, 941,
947, 953, 967, 971, 977, 983, 991, 997

有向图G构造完毕之后，该如何找到最大的数呢？其实就是找到G中，最长的路径。可以采用动态规划来解决。
dp[i]表示，到节点i为止的最长路径。状态转移方程可以表示为：
dp[i] = max(dp[j] + 1), 其中, 节点j是有边指向i的所有节点。
在实现过程中，要注意保存路径，这样才能得到最大数。例如，得到最大的j为j1，则 保存prev[i] = j1。
