Q:给定两个数组X和Y，元素都是正数。请找出满足如下条件的数对的数目：​
	1. x^y > y^x，即x的y次方>y的x次方​
	2. x来自X数组，y来自Y数组  (Done)

假设数组X的长度为m，数组Y的长度为n，最直接的暴力法，时间复杂度为O(m*n)，但这样的话，并不需要都是正数这个条件的。
那么，我们该如何优化呢？​x^y>y^x，对于x和y来讲，有什么规律呢？该如何发现呢？
这里其实有规律的，大多数的条件下，当y>x的时候，x^y>y^x，但是有一些例外，1，2，3，4几个数，需要特殊的考虑，
比如2^4=4^2。这个大家可以通过在纸上写写画画来得到，相对繁琐，我们就不进一步分析了。​
我们可否对于原式做一些数学变换呢？使得式子变化简单。如何去做呢？这个式子的复杂体现在两边都是指数的形式，如何变化一下呢？
我们很自然的就想到，逆运算对数运算，则，两边取对数可得：ylog(x)>xlog(y)。
这里同学们可能要问，可以直接取对数么？取对数之后，大小关系仍旧满足么？这里是有两点保证的：​
	1. 对数函数的性质，单调递增​
	2. 题目中的说明：元素都是正数
对于式子:ylog(x)>xlog(y)，x和y都是正数，则进一步有：两边同时除以xy，则：log(x)/x >log(y)/y。这个式子，看起来也复杂，
但是，x和y都在各自的一边，要简单的多。​对于log(x)/x >log(y)/y，​
	1. 数组X和Y分别计算log(x)/x,log(y)/y​
	2. 然后对Y进行排序O(nlogn)​
	3. 遍历X数组，对于每一个x，在Y中，进行二分查找，即可。​
总的时间复杂度为O(nlogn + mlogn).
-----------------------------------------------------------------------------------------------------------
Q: 给定软件的版本号的表示方式，以及一些版本号，请找出最新的版本。例如：
	1. 1.2，2.2 最新的是2.2
	2. 3.1, 3.1.3 最新的是3.1.3
上面的版本号，都是用字符串表示的。

如果是一个java或者c++的程序员，第一个想到的方法可能是重写比较操作符，然后对字符串整体进行快速排序，
比较的方式就是我们自定义的比较操作符，一个方法，在比较的时候，可以将字符串进行按“.”划分，对应的部分比较数字的大小。
假设有n个版本号，每个版本号的长度为k，则整体的时间复杂度为O(knlogn)，其中，划分并且逐位比较的时间复杂度为O(k)。
是否有更加高效的方法呢？因为我们要找的最新的版本（可以理解为最大的），一般来讲，我们给定一个数组，找到最大的元素
，O(n)的时间复杂度就可以的。同样，在这里我们仍旧可以这样处理：
	1. 用对每一个版本号进行划分，保存为正数的list
	2. 遍历每一个list的第一个元素，找到的最大的数字，也许会有多个
	3. 对于第一个数字最大的一些版本，处理第二个数字，同样找到最大的数字，缩小进一步查找的范围
	4. 依次类推。
这个方法的时间复杂度为O(kn)。
---------------------------------------------------------------------------------------------------------------
Q:城市的环形路有n个加油站，第i个加油站的油量用gas[i]来表示，你有如下的一辆车：
	1. 它的油缸是无限量的，初始是空的
	2. 它从第i个加油站到第i+1个加油站消耗油量为cost[i]
现在你可以从任意加油站开始，路过加油站可以不断的加油，问是否能够走完环形路。如果可以返回开始加油站的编号，
如果不可以返回-1。注意，解决方案保证是唯一的。

这个题目其实比较简单，只要充分的理解，我相信大家都能够解决的。你的这辆车的油缸是无限量的，
所以每个加油站的油都可以加到车里，但是关键是你得保证，你在第i站的时候，油缸中有的油量，可以支撑你到第i+1站，
对于每一站都要如此，所以，并不是总的油量大于消耗量就可以了。要保证每一站都有足够的油可以走到下一站，到每一站，
你的车的油量都大于等于0就可以了。
经过上面的分析，很显然，暴力一点，我们每个站都试一下呗，然后找到每一站的油量都大于等于0的那个走法，返回开始的加油站；
没有就返回-1。这个解法是O(n^2)的时间复杂度。
我们通过观察上面的暴力方法的步骤，可以发现有很大的改进空间。当我们从第0个加油站开始，判断是否可以走完，
然后从第1个加油站开始，进行判断的时候，其实中间的计算已经做过了。反过来，我们如果计算好了从第1个加油开始，到某一个站时，
油量为tank，此时考虑从第0个开始时，到该加油站的油量就是gas[i]-cost[i] + tank。
这时隐约觉得，解决方案的时间复杂度可以是O(n)的时间复杂度。
事实上确实可以，具体的方法如下：tank表示当前车的油缸里的油量
	1. 从第0个站开始，tank += gas[0] - cost[0]，只要tank>=0，我们就继续到下一个加油站
	2. 当不满足tank>=0，顺着环路试验从前一个站开始，比如，n-1: tank += gas[n-1] - cost[n-1]，如果还小于0，
	继续试验再前一个。
	3. 直到满足 tank>=0，再进行第1步，依次类推
	4. 当一前一后这两个相遇了，算法也就结束了，tank>=0，就成功，返回相遇的位置；否则，失败，返回-1

上面这个方法的时间复杂度是多少呢？O(n)的，很简单，我们作为一个整体来看，每一个节点都只走了一次。
-----------------------------------------------------------------------------------------------------------------
Q:翻译数字串，类似于电话号码翻译：给一个数字串，比如12259，映射到字母数组，比如，
1 -> a， 2-> b，... ， 12 -> l ，... 26-> z。那么，12259 -> lyi 或 abbei 或 lbei 或 abyi。输入一个数字串，
判断是否能转换成字符串，如果能，则打印所以有可能的转换成的字符串。

我们这里来分析一下这个题目的分析思路。看完这个描述，我们应该注意到一下的细节：
	* 映射是在[1,26]这个范围内数字
	* 输入的字符串是否包括0或者负数？
这些细节要注意，不明确的要咨询面试官，要不然，很容易让你的程序出现漏洞。面试官也比较在意这个交互的过程。
充分理解题目的含义、目的之后，很直接的就可以想到这个题目可以用递归解决。如原题中的例子：12259，它有两个递归的子问题，
（1）2259和（12）259，前面的括号表示是否能够通过映射表翻译。同理每一个子问题，都会表示为这样的两个子问题。
接下来，我们考虑（1）2259的两个子问题：
	1. （12）259
	2. （122）59
大家有注意到，第一个和12259的一个子问题重复了。大家是否对这个似曾相识呢？当大家把递归过程的树形结构画出来，
会发现更多的重复子问题，这就给了我们改进的空间，只需要取消这些重复计算就可以了。
第一个方法就是记忆法，将计算过的结果缓存起来，这样可以后续接着使用。但是更近一步，我们是可以采用动态规划的方法的。
很多同学也都直接的想到了。
上面的过程，是为初学者指的路，希望能对大家有所帮助。但还有一个细节，大家要注意，这个题目不仅仅是判断是否可以，
还需要打印出来所有的情况。这个细节要在编程的时候注意。
-------------------------------------------------------------------------------------------------------------
Q:给定两个字符串A和B，判断A中是否包含由B中字符重新排列成的新字符串。例如：A=abcdef, B=ba，结果应该返回true。
因为ba的排列ab，是A的子串。(Done)

我们假设A字符串的长度为m，B字符串的长度为n。首先，如果B的长度大于A了，则肯定返回的是false。
所以，我们下面的讨论都是m>=n的情况。
最直接的，我们可以计算出B的所有排列字符串，然后逐个去A中匹配。B的所有排列字符串有n!个，每一个匹配，复杂度较高。
那么如何改进呢？是否可以减少匹配的次数呢？我们首先对B进行排序，采用快排，时间复杂度O(nlogn)，得到D。
然后在A中，从头开始，长度为 n的子串进C行排序，然后判断与C与D是否相同。在A中，一共有m-n+1个长度为n的子串，
每一个子串进行排序，时间复杂度为O(nlogn)，总的时 间复杂度为O((m-n+1)nlogn),O(mnlogn)。
但其实，在A中，只有第一个C的排序时O(nlogn)的，其他的都是去掉第一个字符， 然后插入下一个字符，排序时间复杂度为O(n)，
这样整体的时间复杂度为O(mn)。下面举个例子：
设定A=fedcba, B=ab，则m=6，n=2
	1. 排序B，D=ab
	2. 在A中，第一个长度为2的子串C=fe，排序之后为ef，与D不匹配，则从C中删除第一个字符f，加入下一个字符c，
	此时C=ec。再重复排序的过程。直到A遍历完毕。
明显第一个C需要快排，其他的只需要插入即可。
还有其他的方法，可以用hashmap存储B中的字符，和A中的每一个长度为n的字串进行判断是否匹配。
------------------------------------------------------------------------------------------------------------------
Q:给定一个无序的整数数组，怎么找到第一个大于0，并且不在此数组的整数。比如[1,2,0] 返回 3, [3,4,-1,1] 返回 2。
最好能O(1)空间和O(n)时间。 (Done)

分析首先数组是无序的，找到第一个大于0且不在数组中的元素，就是要找到大于0且不在数组中的最小的整数。
要怎么处理呢？要找到最小的，不妨尝试从小到 大排序，然后从1开始，查找是否在数组中，可以利用二分查找。
这样整体的时间复杂度是O(nlogn)，空间复杂度是O(1)。离题目的要求，还差一些。如何改进呢？针对排序好的数组，我们做如下的观察：
	* 当缺失的数字为1的时候，A[0]<=0, A[1] != 1
	* 当缺失的数字为2的时候，A[0]<=0, A[1] = 1, A[2] != 2
	* 当缺失的数字为3的时候，A[0]<=0, A[1] = 1, A[2] = 2, A[3] != 3
通过上面的观察，可以发现，其实并不需要整个数组是有序的，只需要让数组中的0<A[i]<n的，能够还原到A[i]的位置，
就像缺失3的时候，使得A[1] = 1, A[2] = 2，而且，这两个一定是这样的。后面的序就无需理会了。能够做到，不排序，
就实现位置的还原么？且看如下的算法：由后到前扫描数组：
	1. 如果A[i]=n，则continue；
	2. 如果A[i]=A[A[i]]，则continue；
	3. 如果0<A[i]<n，那么可以还原，则swap(A[i], A[A[i]]),然后跳转到步骤2
然后，数组中如果存在0<A[i]<n的，已经保证A[i]=i了。此时：
	* 从1开始遍历，如果A[i]!=i，则i就是要找的数
	* 如果遍历完，没有找到，则说明i从[1,n-1]，都有A[i]=i，那么这个时候就看A[0]，
	如果A[0]是n，则返回n+1，如果A[0]不是n，则返回n，即可。
上面算法的时间复杂度是O(n)么？有的同学会想，在swap之后，仍然到第2步，可能还会出现交换，所以时间复杂度要高于O(n)。
但实际上，swap之后，是会发生再次的交换，但我们可以保证，每一次交换，都会使得一个数字还原，即A[i]=i，再一次交换，
会让一个新的数字还原。 假设数组中，可以还原的数字个数为k，则需要交换k次，k最多为n-1。这里要很小心，因为总的交换次数是k，
并不是对于每一个元素，都会产生k次交换。 如果是后者，总的时间复杂度就是O(kn)了，但因为总的交换次数是k，
所以总的时间复杂度是O(n+k)，就是O(n)。
---------------------------------------------------------------------------------------------------------------------
Q: 给定未排序的数组，请给出方法找到最长的等差数列。(Done)

题目描述比较简单，但是有一个问题我们需要首先搞清楚：等差数列中的数字，是否要和原始数组中的顺序一致。
题目中，并没有说明，这个就需要大家在面试的过程中和面试官进行交流。我们在这里对两种情况都进行讨论

保证数字的顺序等差数列是要求相邻两个元素之间的差是相同的。那我们可以记录下来数组中任意两个数的差，并且记录下来。
对于数组A，记录A[j]-A[i]，其中 i<j。这里采用hashmap来记录，key就是A[j]-A[i]，value是所有差等于的A[j]-A[i]的(i,j)位置对。
构造 hashmap的过程是O(n^2)的。然后，遍历hashmap的每一个value，对位置对按照起始位置进行排序，
再进行一次遍历就可以得到最长的等 差数列。如下面的数组：{5,4,3,4,7,8} 构造hashmap如下：
	* -1=>(0,1)(1,2)
	* 1=>(2,3)(4,5)
	* 3=>(3,4)
上面已经排好序，对于第一个，找到等差数列0,1,2对应数字诶5,4,3.第二个，3和4位置没有连起来，不够成等差数列。
方法平均时间复杂度为O(n^2),空间复杂度为O(n^2).

无需保证数字的顺序不需要保证数字的顺序与原来数组一致，如何找到最长的等差数列呢？原来的数组是无序的，我们先对数组进行排序，
最终的一定是排序之后序列的子序列。然后，我们采用动态规划的方法解决这个问题。
我们假设dp[i][j]表示以A[i]A[j]开始的数列的长度，dp[i][j]如何表示呢？dp[i][j]=dp[j][k]+1，当 A[j]-A[i]=A[k]-A[j],
及A[k]+A[i]=2*A[j]。根据dp[i][j]的定义，我们知道dp[x][n-1]=2，也就是 最后一列是2，数列只有A[x]和A[n-1]两个元素。
首先，j从n-2，开始向前遍历，对于每一个，找到i和k，满足 A[k]+A[i]=2*A[j]，则有dp[i][j]=dp[j][k]+1，若没有，
则dp[i][j]就为2.
这里找i和k，有一个小技巧，如下：初始i=j-1,k=j+1，然后分别向两边遍历，如果A[k]+A[i] < 2*A[j]则i--。
--------------------------------------------------------------------------------------------------------------------
Q:数组A中，除了某一个数字x之外，其他数字都出现了三次，而x出现了一次。请给出最快的方法，找到x。

乍一看这个题目，不少同学立马给出了答案：异或。但举个例子，就会发现，异或是行不通的，一般的方法是利用异或的的如下特性：
  A xor A = 0
  A xor 0 = A
但是这个题目中，数字都是奇数个的，直接采用之前类似题目的异或方法，已经不合适了。
除此之外，我们还可能想到如下的方法：
    采用hashmap，时间复杂度O(n)，空间复杂度O(n)
    对数组A进行排序，然后在遍历一次，时间复杂度O(nlogn)，空间复杂度O(1)
是否还有一些效果更好的方法呢？这一类的题目，即使简单的异或不能解决，也可以从二进制位、位操作方面去考虑
，总之这样的大方向是不会错的。
题目中，如果数组中的元素都是三个三个出现的，那么从二进制表示的角度，每个位上的1加起来，应该可以整除3。
如果有一个数x只出现一次，会是什么情况呢？
    如果某个特定位上的1加起来，可以被3整除，说明对应x的那位是0，因为如果是1，不可能被3整除
    如果某个特定位上的1加起来，不可以被3整除，说明对应x的那位是1
根据上面的描述，我们可以开辟一个大小为32的数组，第0个元素表示，A中所有元素的二进制表示的最低位的和，依次类推。
最后，再转换为十进制数即可。这里要说明的是，用一个大小为32的整数数组表示，同样空间是O(1)的
-----------------------------------------------------------------------------------------------------------------------
Q:给定平面上的两个格点P1(x1,y1)，P2(x2,y2)，在线段P1P2上，除P1、P2外，一共有多少个格点？格点定义为x和y都是整数的点。

这是一个简单的题目，方法比较多了，比如，首先求的直线的方程式：y=ax+b。然后在x轴，从x1+1开始，到x2-1结束，
将每一个整数带入上面的方程式，得到y值。如果y满足y1<y<y2，则找到一个格点，遍历完毕之后，得到全部的格点。
时间复杂度，O(|x2-x1|)。也是比较快的。还有更暴力的方法，时间复杂度为O(|x2-x1|*|y2-y1|)，
从这个大家可以看出来，完全是遍历每一个整数点，看是否落在直线上。
那么有没有更快的方法呢？这个题目实际上是求|x1-x2|和|y1-y2|的最大公约数，格点数目就是最大公约数减取1。
大家可以画画图，验证这个方法。最好是画一个棋盘。
大家还记得最大公约数是怎么计算的么？辗转相除法。设a和b的最大公约数为gcd(a,b)，则gcd(a,b) = gcd(b, a%b)。
公式比较简单，改如何分析时间复杂度呢？是否更快呢？
我们假设a>b，则有如下的过程
gcd(a, b) = gcd(b, a%b) = gcd(a%b, b % (a % b)) …
一直递归到结束，gcd(x, 0) = x。
	* 当b>a/2时，a % b = a - b < a / 2
	* 当b<a/2时，a % b < b < a / 2
每一次新的递归，第一个参数都要小于原来的一半，所以，估计其时间复杂度在O(log max(a,b))以内，
这里的a和b分别为|x1-x2|和|y1-y2|。比线性的解决方案要快。
---------------------------------------------------------------------------------------------------------------------
Q:为了修理栅栏，需要将很长的木板锯为N块，长度分别为L1,L2...LN。锯断一块儿木板，需要一定的开销，开销记为木板的长度。
例如，长度为21的木板，锯为三块，长度分别为5，8，8。如下按照如下的顺序据断：
	* 首先锯断21为13和8两块儿，开销为21
	* 然后锯断13为8和5两块儿，开销为13
总的开销为34。但也可以按照如下的顺序：
	* 首先锯断21为16和5两块儿，开销为21
	* 然后锯断16为8和8两块儿，开销为16
总的开销为37。比34要大。问题是，给定N，以及每一块儿的长度。如何保证最小的开销。尽量采用高效的方法。

这个题目，要如何分析？这切锯成N块的方法太多了。如何入手呢？其实，题目中的两个例子，都可以表明，
我们可以将切割的过程用二叉树表示：
            21
        13      8
     8      5
以及
             21
          16      5
       8      8
根据上面两棵二叉树，得到开销的计算方法：
	* 第一棵树，开销34 = 8 * 2 + 5 * 2 + 8 * 1 = 34
	* 第二颗树，开销37 = 8 * 2 + 8 * 2 + 5 * 1 = 37
也就是所有的叶子节点的长度乘以深度。叶子节点，就是各个木块儿的长度。从上面的式子，我们可以得出，要想开销最小，
树的高度是不变的，那就一定要越短的木板，深度越深，即可。而且，因为一次锯开，肯定是两块儿，
所以，要保证整个开销最小，则最短的和次短的木板一定是兄弟，这样，可以递归使得，父亲节点的开销也是最小的。
这样，求的最小开销就很简单了，去最短和次短木板，加起来，得到一个开销，假设L1是最短的，L2是次短的。
则递归处理(L1+L2)以及剩下的木板即可。这个复杂度是O(N^2)的。

那么是否有更高效的方法呢？上面的方法，是从底向上计算的。锯的时候，如何做呢？从最长的开始，每次都把最长的锯掉。
这样排序O(NlogN)。从最大的开始锯。解决。
----------------------------------------------------------------------------------------------------------
Q:有N个木桩，高度分别为1到N。你现在要将木桩排列为一行，当你从左边看的时候，只看到L个木桩
(因为，一些高的木桩会挡住矮的木桩)；从右边看时，只看到R个木桩。给定N、L、R，你该如何排列木桩呢？
例1：N=3,L=2,R=1，可行的排列方案只有{2,1,3}。
例2：N=3,L=2,R=2，可行的排列方案有{1,3,2}{2,3,1}

开始排列木桩的时候，应该如何选取第一根木桩呢？一个很直接的选择就是先确定最高的木桩的位置，也就是N。
因为，无论从左到右，还是从右到左看，都要到最高停下来。
确定了最高的木桩之后，无论从哪一边看，都至少有一个木桩。接下来，该如何处理？想必大家已经想到了，开始递归呗。
左右两边，也同样是先确定最高的木桩的位置，依次递归下去。
构造的方法，是比较简单地。但，往往这个时候面试题并没有结束。面试官，会进一步问：给定NLR，有多少种排列木桩的方法呢？
从一个构造问题，转变为一个计数的问题。该如何做呢？方法仍旧是递归，我们尝试写出递归表达式。
假设，b(N,L,R)表示排列方案的总数。f(N, L)表示N个木桩，排列得到从左边能够看到L个木桩的方案总数。我们从f的递归形式入手分析。
首先，f(N,N)=1。从左到右，从低到高排列，只有一个方案。
然后，f(N,M)=0,当N<M时。显而易见。
其次，f(N,1)=(N-1)!。当只看到一个木桩的时候，即最高的木桩排在最左边，其他的木桩无论怎么排列都可以。
再次，假设最高的木桩放在从左边开始的第k个位置，则，我们要在剩下的N-1个木桩里面，选取k-1个木桩放在最高木桩的左边，
并且，找到能看到L-1个木桩的方案数(因为最高的木桩一定能看见，所以是L-1个)，此时剩下的N-K个木桩，可以任意排列，
得到递归表达式如下：
f(N, L) = sum_{L<=k<=N} (N-1 选择 k-1) * f(k-1, L-1) * (N-k)! 
这个式子，是仅仅考虑了总左边看到L个柱子的情况，再需要考虑，从右边看，有R根柱子的方案呢？
其实很简单了，剩下的N-k个柱子，不要任意排列，要保证从右边能够看到R-1个柱子即可。所得递归式如下：
b(N,L,R) = sum_{L<=k<=N-R+1} (N-1 选择 k-1) * f(k-1, L-1) * f(N-k,R-1) 

------------------------------------------------------------------------------------------------
Q:X和Y都是只有0和1组成的字符串。D(X,Y)称为模糊距离，定义如下：首先删除X和Y从头开始的公共子串
然后将X和Y剩下部分的长度相加得到模糊距离
例如D(1000,1111)，首先，删除子串“1”，然后剩下“000”和“111”长度都是3，相加为6，则
D(1000,1111)=6。
例如D(101,1100)，首先删除公共子串“1”，然后剩下"01"和"100"长度分别为2，3，相加为5，则
D(101,1100)=5。
问题是，给定n个只有0和1的字符串，如：
1111
1000
101
1100
...
请找到最大的模糊距离，字符串总数为n，字符串最长为m。 (Done)

直接想来，对于每一个01字符串，与其他的每一个01字符串进行模糊距离的计算，时间复杂度是O(nm)，遍历完n个字符串，
总的时间复杂度是O(n^2*m)。这个我们可以称为暴力法。
如何改进上面的方法的，主要是指缩小时间复杂度。一个非常通用的方法，就是以空间换时间。如何换呢？
对于模糊距离的第一个条件，我们想到什么呢？公共前缀，不知道同学们，联想到树形结构：trie树没有。
例如：给定000、001、0010，我们构造如下的trie树。

构造过程中，1为左子树，0为右子树。模糊距离的第一个条件是，去掉公共前缀，则计算时，两个字符串，要有公共前缀，
也就意味着，只需要考虑开始分叉的节点，左右子树，可以有一个没有。这样，我们考虑第一个分叉的节点：0，
然后可以计算第二部分了，如何计算剩下长度相加呢？
尤其，为了找到模糊距离的最大值，我们求得当前节点的左子树的最大深度以及右子树的最大深度，两者相加，
及得到一个模糊距离，为3。然后考虑1节点，右子树为空，则模糊距离为1。综合，最大的模糊距离为3。
这里有一个小小的技巧，构建的过程中，可以在节点中，存储左右子树的高度，并随着加入新的字符串，更新左右子树的高度。
总的时间复杂度为O(nm)。 根据上例，存储的左右子树的高度值变化如下 (left_height, right_height):
	* left_height: 左边子树的高度
	* right_height: 右边子树的高度

-------------------------------------------------------------------------------------------------------------------
Q:盒子中有n张卡片，上面的数字分别为k1,k2,...,kn。你有4次机会，每抽一次，记录下卡片上的数字，再将卡片放回盒子中。
如果4个数字的和等于m。则你就赢得游戏，否则就是输。直觉上，赢的可能性太低了。请你给出程序，判断是否有赢的可能性。

这个题目最直接的方法就是四重循环遍历，n^4的时间复杂度，比较恐怖，但确实一个很好的起点。
不用觉得很丢人，只要我们持续改进即可。
假设a，b，c是k1到kn中的三个数字，是否存在d使得，a+b+c+d=m？d在k1到kn中。和题目中的意思是一样的，变换等式如下：
d = m - a - b - c
如果满足上式，就是说，要在k1到k2中查找d，即：查找m - a - b - c，找到就存在；找不到，就是不存在。
查找有线性查找，二分查找等。四重循环最内一层循环，可以认为是线性的查找，如果想更快一些，可以应用二分查找，
而二分查找需要k1到kn是排序的，则先对n个数字进行排序，时间复杂度O(nlogn)。
然后最内一层循环，改为二分查找，时间复杂度为O(n^3logn)。所以总的时间复杂度为O(n^3logn)。

经过上面的分析，我们可以得到启发，既然可以提出一个d，那么就可以再提出一个c。将a+b+c+d=m转换为c+d=m-a-b。
这样，我们可以枚举k1到kn的两个数的和，然后对n2个和，进行排序，时间复杂度为o(n^2logn)。
然后遍历n^2个和，设每一个和为pair，查找是否存在m-pair，同样二分查找，时间复杂度为O(n^2logn)。总的时间复杂度为O(n^2logn)。
--------------------------------------------------------------------------------------------------------------------
Q: 求正数数组内和为指定数字的合并总数
比如[5, 5, 10, 2, 3] 合并值为 15 : 有4种 ： (5 + 10, 5 + 10, 5 + 5 + 2 + 3, 10 + 2 + 3)

我们设定f(index，sum)表示数组从index开始到结束组成的sum的总数。那么，f(index, sum)可以表示为什么呢？ 
我们这个题目，就是要最终求得f(0, 15)，从头开始分析，最终组成的和为15的可能组合中，可能包含第0个元素，也可能不包含, 
原始数组为A：
	* 当包含第0个元素时，剩下的表示为f(1, 15-A[0])
	* 不包含第0个元素时，剩下的表示为f(1, 15)
则，f(0, 15) = f(1, 15) + f(1, 15 - A[0])。依次递归。递归的终止条件是什么呢？对于f(index,sum):
	* 当和小于等于0的时候，f(index,sum) = 0
	* 当和小于sum的时候， f(index, sum) = f(index + 1, num);
	* 当和等于sum的时候，f(index, sum) = 1 + f(index + 1, sum);
但是，上面的条件，并没有使用题目中，数组全是正数，也就是存在负数也可以。如果仅仅是正数，后两个改为：
	* 当和小于sum的时候， f(index, sum) = 0;
	* 当和等于sum的时候，f(index, sum) = 1;
有一个条件，我们没有使用，也意味着提升的空间。
可是，上面的方案，时间复杂度是指数级。怎么做一些改进呢？一般在对一个算法进行优化的时候，有哪些思路呢？
尤其是这种时间很恐怖的？我想很多同学都有这个经验，就是空间换时间。
大家可以想象动态规划的思想，大家看如下的状态转移方程：
dp[n][m]=dp[n-1][m]+dp[n-1][m-num[n-1]]
dp[n][m]表示前n个元素组成和为m的情况数。初始化dp[0][0]=1，其他为0。
写出状态转移方程，大家也就明白了，为何要求全是正数了吧，直白一些，数组的索引，怎么可能为负呢？
在计算的过程中，将和的情况保存下来，用空间换时间，整个算法的时间复杂度为O(n*m)，不再是指数级。
-------------------------------------------------------------------------------------------------------------
Q:给定无序数组A，在线性时间内找到i和j，j>i，并且保证A[j]-A[i]是最大的。

这个题目是比较简单的。很直接的，对于每一个A[j]，如果知道前面的元素中最小的元素min，则此时相差最大为A[j]-min。
则，假设有一个数组M，M[j]表示[0,j-1]中最小的元素。这个遍历一边A，就可以完成构造M。再遍历一边数组，就可以找到相差最大的。
我们举个例子看看M，以及是否有改进的空间。
就是并不需要一个数组保存最小值，而只需要一个变量即可。
上面的例子不明显，假定A={2,5,1,3,4}，过程如下：
j  A[j]  最小值m   A[j]-m
0   2      2         0
1   5      2         3
2   1      1         0
3   3      1         2
4   4      1         3
最终得到相差最大为3.这个例子，可以找到两个i，j。

---------------------------------------------------------------------------------------------------------
有一座金字塔，从上到下，第一层有一个杯子、第二层有两个杯子，依次类推。对杯子进行编号，有如下的形状：
   1
 2   3
4   5   6
每个杯子的容量为C升，从塔顶倒下L升水，当1号杯子满了之后，会等量溢出到2号和3号杯子。
当2号和3号满了，2号溢出到4号和5号，3号溢出到5号和6号，注意5号接受来自两个杯子的水。依次类推。
给定C和L，请问，第n杯里有多少水。

这个类型的题目，关键点就是明了水倒下来的过程。我们这里做简单的分析， 假设L>C, 如果L
金字塔深度0 1 1 2 2 2
杯号      1 2 3 4 5 6
A索引     0 1 2 3 4 5
观察上面的表格，我们会发现，一个规律，i号杯深度为h，则i号中溢出的水，将平分进入：
	* i + h + 1
	* i + h + 2
比如，文章开始的图中，3号杯进入5号和六号，3号杯的h为1，则
	* 5 = 3 + 1 + 1
	* 6 = 3 + 2 + 2
利用这个技巧，可以在数组中存储树形的金字塔，并且可以很方便的找到孩子节点。
计算出所有的A[i]之后，要得到最后的答案，还有一部之遥。即：
	* A[i] >= C ? C : A[i]

--------------------------------------------------------------------------------------------------------------
//一个数组A[1...n]，满足A[1]>=A[2], A[n] >= A[n-1]。A[i]被成为波谷，意味着：A[i-1] >= A[i] <= A[i+1]。
//请给出一个算法，找到数组中的一个波谷。O(n)的方法，是很直接，有更快的方法么？
找到数组的mid元素，mid有几种情况：
	* 如果A[mid-1]>=A[mid] && A[mid+1]>=A[mid]，找到波谷；
	* 如果A[mid-1]<=A[mid]<A[mid+1]，right=mid，在左侧继续找；
	* 如果A[mid+1]<=A[mid]<A[mid-1]，left=mid，在右侧继续找；
	* 如果A[mid-1]<A[mid] && A[mid+1]<A[mid]，任意一侧都可以，任意一侧，都必将存在波谷。

--------------------------------------------------------------------------------------------------------------
//排序只有1，2，3三个元素的数组，不能统计1，2，3的个数。
1. p1从左侧开始，指向第一个非1的数字；p3从右侧开始，指向第一个非3的数字。
	1. p2从p1开始遍历，如果是2，p2继续遍历，直到p2遇到1或者3
	2. 如果遇到1，则和p1进行交换，然后p1向右，指向第一个非1的数字
	3. 如果遇到3，则和p3进行交换，然后p3向左，指向第一个非3的数字
重复上面的步骤，直到p2在p3的右侧结束。
2. 思路来自快排的划分部分，快排的划分部分：给定pivot，然后将数据划分为<=pivot和>pivot两部分。
这样，三个数字时，需要两次划分：
	1. 第一次，用1作为pivot,划分1到最左边；
	2. 第二次，用2作为pivot，划分2到左边，则得到整体的排序
3. 我们将1，2，3，替换为互质的2，3，5
之后，乘起来得到的900.这900里，除以2，有多少个2，就有多少个1；
然后除以3，有多少个3，就有多少个3对应的2；然后除以5，有多少个5，就有多少个5对应的3。

-----------------------------------------------------------------------------------------------------------
//给定一个数组，数组中只包含0和1。请找到一个最长的子序列，其中0和1的数量是相同的。
//例1：10101010 结果就是其本身。
//例2：1101000 结果是110100
原来是0和1的串，我们将0都换为-1。这样题目目标就变成，找到一个最长的子串，子串数字和是0。
如果DP[i]==DP[j]，i 一种方法，我们用map保存DP的值到位置的映射，如下表：
上面的这个思路，时间复杂度是O(n),空间复杂度也是O(n).
-----------------------------------------------------------------------------------------------------------

//给定只包含正数的数组，给出一个方法，将数组中的数拼接起来，得到的数，是最大的。 
//例如： [4, 94, 9, 14, 1] 拼接之后，所得最大数为：9944141
一次排序，就得到了结果。给定例子：5,54,56
	1. 比较5和54，实际上就是比较545和554哪个大
	2. 比较5和56，实际上就是比较556和565哪个大
	3. 比较54和56，实际上就是比较5456和5654哪个大
那我们对快排程序做一下变化，当两个数字a和b进行比较时，比较的是ab和ba两个数字的大小即可。
只是比较发生了变化，剩下的和快排都是一样的。 (Done)

--------------------------------------------------------------------------------------------------------------
//给定一批查询日志，数量为n。其中，有的查询出现了多于n/3次，请在线性时间内，找到所有满足条件的查询。

1.采用hashmap进行计数，O(n)的空间，O(n)的时间
2.进行排序，O(nlogn)
3.快速选择算法，这个也可以做到O(n)的时间。
4.我们申请一个大小为m的map，开始遍历查询日志，如果：
  1. 遇到一个不在map中的查询，则插入map中，并且将值设置为1（相当于新落下一个方块）
	2. 遇到一个在map中的查询，则将map中，该查询对应的值加1（相当于在已有的方块上又多加了一个）
当map中的查询个数等于m时，则对map中所有查询的值减一（相当于砌满了一层，就会消掉）。
直到遍历完毕查询日志，map中还存在的查询，就是我们要找的查询的备选。

-------------------------------------------------------------------------------------------------------------------
//大家都知道facebook用户都是双向的好友，a是b的好友，那么b一定是a的好友，现在给定一个用户列表，
其中有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，并且每组内的用户，互相都不是好友。
如果能，请给出这个划分。
例子1： 用户：{1, 2, 3} 好友关系：1-2， 2-3 划分：{1,3} {2}
例子2： 用户{1,2,3,4} 好友关系：1-2， 2-3， 3-4，4-1 划分：{1, 3}{2, 4}

相对而言，今天的面试题目比较简单。因为建模的部分，已经在题目中给出了。稍想一下，图分割的问题。
facebook的好友关系是双向的，意味着是无向图（新浪微博，twitter都是有向图）。然后，要把图划分为两组，这两组满足什么条件呢？
组内没有边，组间有边。这显然就是一个二分图。
那问题很明显了，就是facebook好友关系构成的图，是否是一个二分图？如果是，请找到这个划分。就是二分图判断+找到一个划分即可。
根据二分图的特性，一条边上的两个点，肯定是属于不同的组。如果它们出现在同一个组中，肯定就不是二分图了。
怎么判断，一条边上的两个点，分属于不同的组呢？我们需要遍历图，如果找到一条边，两个节点，都在同一组，则不是二分图；
如果图遍历完成之后，没有找到这样的边，则是二分图。我们在遍历的过程中，我们需要区分，一条边的两个节点分属于不同的组，
这里我们用到了染色法。核心思想如下：
从某一个点开始，将这个节点染色为白色，并且开始广度优先遍历，找到与其相邻的节点，如果是二分图，相邻节点的颜色都应该不同。
如果是黑色，则不变；如果是无色，则染成黑色；如果是白色，也就是同色，程序退出。
当图遍历完毕时，没有相邻节点同色的，则是二分图，标记为白色和黑色的两组就是一个划分。

-----------------------------------------------------------------------------------------------------------------------
//Q:Describe an algorithm that takes an unsorted array of axis‐aligned rectangles and
//returns any pair of rectangles that overlaps, if there is such a pair. Axis‐aligned
//means that all the rectangle sides are either parallel or perpendicular to the x‐ and
//y‐axis. You can assume that each rectangle object has two variables in it: the x‐y
//coordinates of the upper‐left corner and the bottom‐right corner.

Good Answer: Create a sorted array of the x coordinates of the left and right edges of
the rectangles. Then, use a "scanline" to move from left to right through the
rectangles. Keep a binary search tree containing the y coordinates of the top and
bottom edges of the rectangles that overlap the scanline. For each element of the
array, check whether it is a left or right edge. If it is a right edge, remove the
corresponding top and bottom edges from the BST. If it is a left edge, search the BST
for rectangles that overlap the current rectangle; if there is one, return the overlap.
Then, add the y coordinates of the top and bottom edges of the rectangle to the BST.
The search takes O(n log n) time, since it takes O(n log n) time to sort the rectangles
and each of the 2n iterations takes O(log n) time.

----------------------------------------------------------------------------------------------------------
//Q: 给你一个数组，它有N个8-bit整数， （比如，从0到255）， 和M个子数组，
//[i, j] （每个子数组由两个下标 i 和 j 确定，0 <= i <= j < N）。对每个子数组，找到平均值和中值。
A: 原数组为b「」，新建一个n位整数数组a「」，a「i」的值为b「0」到b「i」的累加值。
求平均值和中直操作是o（1），构造数组是哦（n）。算法复杂度o（n）
上述方法求平均值可以是O（1），但中值是怎样求？感觉还要有一个数组c[N][256],
c[i][k]里面放b[0]到b[i]中k值出现的次数，对任何i j 中值保证在O(256)时间里求出。


// Q: 每个任务之间有dependency，怎么安排任务顺序，使得执行任务i的时候，所有被depend的任务已经执行过了。

A: 1. 拓扑排序 2. PERT网络 3. 建筑施工网络规划问题 4. 做邻接矩阵，每次删除出度为零的节点

----------------------------------------------------------------------------------------------------------------
Q: 给定一个大整数N，有如下的初始有序序列位于[0, N - 1]之间（见图）。请设计一个数据结构保存这个初始序列，
   然后写一个函数，接受一个input参数x, 满足0 <= x <= N - 1。 
    1) 假如x在该结构中不存在，出错处理； 
    2) 假如x在该结构中存在，返回x之后第一个不存在的数，并把该数写入结构中

例如N=100， 有如下的序列 
[0 1] [4, 5, 6] [9 10 11] [20] [90] [95 96] [98 99]
x = 8, error
x = 5, return 7, 
[0 1] [4, 5, 6 7] [9 10 11] [20] [90] [95 96] [98 99]
x = 95, return 97,
[0 1] [4, 5, 6] [9 10 11] [20] [90] [95 96 97 98 99]
x = 96, error.

A: 1.线段树， 2.bitmap， 3.B tree, 4.用两个vector分别保存每个区间的最大最小值 用二份查找到查询数所在区间

----------------------------------------------------------------------------------------------------------------
Q: 在一个大串中查找和另外一个字符串是anagram的子串。
   比如，GetAnagram("abcdbcsdaqdbahs'', "scdcb'') ==> "cdbcs''
    TopCoder -- Anagrams problem

A: 1. 一个长26的数组记录子串每个字符出现次数，大串中遍历一次，遇到相同的字符就在数组中-1，
      如果某字符计数已经是0就从下个位置重新开始，直到所有字符的计数刚好为0就找到匹配
   2. 可以这样试试，先将子串的字符加起来，得到一个和。然后在母串中找等于该和的子串。
      但是等于该和的子串不一定就是要找的子串。也就是还得检查一遍
   3. 对后面一个串进行hash，源串中用两个快慢指针（两指针见长度固定）。每次匹配完，检查是否所有元素全部匹配。
      时间复杂度O(M*N) 空间复杂度为O(2*N) 
-----------------------------------------------------------------------------------------------------------------
Q: 请构造程序，找到满足如下条件的最大数：
假设最大数表示为，abcdefghihk..... 每一个字母表示一位，其中
abc，bcd，cde...以此类推，每三个一组，构成的数字是素数，也就是说abc, bcd, cde，等，都是素数，而且这些素数是互不相同的。

我们首先对这个题目进行建模，构造一个有向图G。G中的节点就是三位素数，比如abc，bcd，def都是三位素数，
则他们都是有向图G中的节点。其中，abc和bcd之间有abc指向bcd的边。abc、bcd则与def之间没有边。如此，构造完整G。
大家可以在纸上画一画。所有的三位素数如下：
101, 103, 107, 109, 113,
127, 131, 137, 139, 149, 151, 157, 163, 167, 173,
179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
233, 239, 241, 251, 257, 263, 269, 271, 277, 281,
283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
467, 479, 487, 491, 499, 503, 509, 521, 523, 541,
547, 557, 563, 569, 571, 577, 587, 593, 599, 601,
607, 613, 617, 619, 631, 641, 643, 647, 653, 659,
661, 673, 677, 683, 691, 701, 709, 719, 727, 733,
739, 743, 751, 757, 761, 769, 773, 787, 797, 809,
811, 821, 823, 827, 829, 839, 853, 857, 859, 863,
877, 881, 883, 887, 907, 911, 919, 929, 937, 941,
947, 953, 967, 971, 977, 983, 991, 997

有向图G构造完毕之后，该如何找到最大的数呢？其实就是找到G中，最长的路径。可以采用动态规划来解决。
dp[i]表示，到节点i为止的最长路径。状态转移方程可以表示为：
dp[i] = max(dp[j] + 1), 其中, 节点j是有边指向i的所有节点。
在实现过程中，要注意保存路径，这样才能得到最大数。例如，得到最大的j为j1，则 保存prev[i] = j1。
